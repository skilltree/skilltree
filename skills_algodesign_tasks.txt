Algorithm Design Verification Challenges

Lv. 1:
  Build a program that implements bubble, selection and insertion sorts on arrays, linked lists, stacks, and queues.
  Draw different types of graphs and trees and be able to distinguish between them (e.g. a non-directed, non-weighted graph of vertices on a geometric solid; a weighted graph for toll roads between cities; a directed graph for a choose-your-own-adventure story; a family tree; etc.)

Lv. 2: (Probably only need to complete some percentage of these tasks)
  Build a program that sorts arrays of numbers using quicksort and mergesort.
  Build a program that uses arrays of numbers to populate heaps and BSTs, and use those to sort the arrays.
  Build a program that converts a given (non-directed) graph into a tree using breadth-first search.
  Build a program that sorts the nodes in a directed acyclic graph (this is topological sort, uses depth-first search)
  Build a program that finds the strongly connected components of a directed graph.
  Construct proofs for your program(s) showing their complexity and correctness.
  Construct a proof comparing insertion and selection sort, demonstrating which is better for which cases.

Lv. 3: (My knowledge here is a little spotty)
  Build a program that finds the minimum spanning tree and shortest path for a graph.
  Build a program that can find the optimum path in a flow networked graph.
  Build a program that finds all the prime factors of a number (using dynamic programming).
